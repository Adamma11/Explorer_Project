const UserPassword = require('../../models/administration/user_password.model')
const User = require('../../models/administration/user.model')
const RefreshToken = require('../../models/administration/refresh_token.model')
const generateToken = require('../../shared/generate_token');
const UserRole = require('../../models/administration/user_role.model')
const express = require('express');
const nodeMailer = require('nodemailer');
const { resolveContent } = require('nodemailer/lib/shared');
const { rejectConvertRequest } = require('../sales/lead_or_prospect.controller');
const ScreenAccess  = require('../../models/administration/screen_access.model');
const { response } = require('express');
const crypto = require('crypto');
const { sendMail } = require('../mails/send_mail.controller');
//const bcrypt = require('bcryptjs');
const oauth2 = require('simple-oauth2');
const { ClientCredentials } = require('simple-oauth2');
const axios = require('axios');
const { ConfidentialClientApplication } = require('@azure/msal-node');





/*exports.create = (req,res)=>{
    UserPassword.deleteOne({user:req.body.user})
    .then(userPassword=>{
        savePassword();
    })
    function savePassword(){
        const userPassword = new UserPassword({
            user:req.body.user,
            password:req.body.password
        })
        userPassword.save(userPassword)
        .then(data=>{
            let transporter = nodeMailer.createTransport({
                host:"smtp.office365.com",
                port:587,
                secure:false,
                auth:{
                    user:"info@adamma.in",
                    pass:"Adamma@123"
                }
            })
            let mailOptions = {
                from:"info@adamma.in",
                to:req.body.userId,
                subject:"Welcome to Explorer (Powered by Adamma)",
                text: "Dear " + req.body.name + ",\n\n" + "Welcome to Explorer!\n\n" + "Your account has been created. You can now login using the following credentials.\n\n" + "URL:https://uat-explorer.adamma.in\n" + "User ID :" + req.body.userId + "\n" + "Password :" + req.body.password + "\n\n" + "Please change the password immediately after the first login.\n\n" + "Need any help with the account?" + "Write to info@adamma.in\n\n" + "This is autogenerated email, please do not respond.\n\n" + "Thank you,\n" + "Team Explorer"
            }
            transporter.sendMail(mailOptions,function(error,info){
                if(error){
                    console.log(error);
                    res.status(500).json({message:error.message || "Some error occured while saving user password"})        
                }else{
                    res.status(200).json({message:"Password generated successfully"});
                }
            })
            
        })
        .catch(err=>{
            res.status(500).json({message:err.message || "Some error occured while saving user password"})
        })        
    }

}*/
exports.create = async (req, res) => {

    try {

      await UserPassword.deleteOne({ user: req.body.user });

      const userPassword = new UserPassword({
        user: req.body.user,
        password: req.body.password,
      });

      const data = await userPassword.save();
    const accessToken = await getAccessTokenGraph();
    await sendForgotPasswordEmail(req.body.userId, req.body.password, accessToken);

      console.log("Email sent successfully:", response.data);
      res.status(200).json({ message: "Password generated and email sent successfully" });

    } catch (err) {
      console.error("Error:", err.response ? err.response.data : err.message);
      res.status(500).json({
        message: err.message || "Some error occurred while processing the request",
      });
    }
  };
exports.validateOtp = (req,res)=>{
    console.log("In validate Otp ",req.body.userId)
    let validateTheUser = function(){
        return new Promise(function(resolve,reject){
            User.findOne({userId:req.body.userId})
            .then(user=>{
                if(user != null){
                    resolve(user._id)
                }else{
                  reject(null);
                }
            })
            .catch(err=>{
                console.log("Error finding the user")
                reject(null)
            })
        })
    }


   let compareOtp = function(user_id){
      return new Promise(function(resolve,reject){
         console.log("Tryin to find otp ",req.body.otp)
         UserPassword.findOne({user:user_id})
         .then(data=>{
            console.log("OTP in db is ",data.otp)
            if(data.otp == req.body.otp){
              const accessToken = generateToken({user_id:user_id},"ACCESS")
//            console.log("Access token  is ",accessToken)
              resolve(accessToken)
            }else{
              console.log("otp not found")
              reject(null)
            }
         })
         .catch(err=>{
             reject(null)
         })
      } )
   }

   let getUserRoles = function(user_id){
        return new Promise(function(resolve,reject){
            UserRole
            .find({user:user_id})
            .then(data=>{
                let roles = new Array();
                data.forEach(item=>{
                    roles.push(item.role);
                })
                resolve(roles);
            })
            .catch(err=>{
                reject(null);
            })
        })
    }
    let getScreensForRoles = function(roles){
        return new Promise(function(resolve,reject){
            let roleObjectArray = new Array();
            roles.forEach(item=>{
                let roleObj = ({
                    role:item
                })
                roleObjectArray.push(roleObj);
            })
            ScreenAccess
            .find({$or:roleObjectArray})
            .populate({path:'screen'})
            .then(data=>{
                let screens = ''
                data.forEach(item=>{
                    let requiredScreen = ({
                        screen_id:item.screen._id,
                        name:item.screen.name,
                        code:item.screen.code
                    })
                    screens = screens + item.screen.code + ','
                })
                console.log("screens being sent back is ",screens);
                resolve(screens)
            })
            .catch(err=>{
                reject(null);
            })
        })
    }


    validateAndSendTheRequiredData();
    async function validateAndSendTheRequiredData(){
        try{
            console.log("Trying to get user_id")
            let user_id = await validateTheUser();
            console.log("Got user id ",user_id)
            if(user_id == null){
                console.log("User Id is null");
                res.status(401).json({message:"Invalid User"})
            }else{
                let accessToken = await compareOtp(user_id);
                if(accessToken == null){
                    res.status(401).json({message:"Invalid Otp"})
                }else{
                    console.log("Access token not null ",accessToken)
                    let userRoles = await getUserRoles(user_id);
                    let screensForRoles = await getScreensForRoles(userRoles);
                    console.log("Screens for  roles" ,screensForRoles);
                    res.status(200).json({accessToken:accessToken,roles:userRoles,screens:screensForRoles})
                }
            }
        }catch(err){
            res.status(401).json({message:"Invaid User / Password"})
        }

/*         console.log("Screens required are ",screensForRoles);
        if(accessToken != null){
            console.log("Validation successful");
            res.status(200).json({accessToken:accessToken,roles:userRoles})
        }else{
            console.log("Validation failure");
            res.status(401).json({message:"Password Validation Failed"});
        } */

    }


}

/*exports.validate = (req,res)=>{
    let validateTheUser = function(){
        return new Promise(function(resolve,reject){
            User.findOne({userId:req.body.userId})
            .then(user=>{
                if(user != null){
                    resolve(user._id)
                }else{
                  reject(null);
                }
            })
            .catch(err=>{
                reject(null)
            })            
        })
    }

    let comparePasswords = function(user_id){
        return new Promise(function(resolve,reject){
            UserPassword.findOne({user:user_id})
            .then(userPassword=>{
                if(userPassword){
                    userPassword.comparePassword(req.body.password,function(err,isMatch){
                        if(err){
                            reject(null);
                        }
                        if(isMatch){
                            const accessToken = generateToken({user_id:user_id},"ACCESS");
                            resolve(accessToken)
                        }else{
                            reject(null)
                        }
                    })
                }else{
                    reject(null)
                }
            })
            .catch(err=>{
                reject(null);
            })
        })

    }
    let getUserRoles = function(user_id){
        return new Promise(function(resolve,reject){
            UserRole
            .find({user:user_id})
            .then(data=>{
                let roles = new Array();
                data.forEach(item=>{
                    roles.push(item.role);
                })
                resolve(roles);
            })
            .catch(err=>{
                reject(null);
            })
        })
    }
    let getScreensForRoles = function(roles){
        return new Promise(function(resolve,reject){
            let roleObjectArray = new Array();
            roles.forEach(item=>{
                let roleObj = ({
                    role:item
                })
                roleObjectArray.push(roleObj);
            })
            ScreenAccess
            .find({$or:roleObjectArray})
            .populate({path:'screen'})
            .then(data=>{
                let screens = ''
                data.forEach(item=>{
                    let requiredScreen = ({
                        screen_id:item.screen._id,
                        name:item.screen.name,
                        code:item.screen.code
                    })
                    screens = screens + item.screen.code + ','
                })
                console.log("screens being sent back is ",screens);
                resolve(screens)
            })
            .catch(err=>{
                reject(null);
            })
        })
    }

    validateAndSendTheRequiredData();
    async function validateAndSendTheRequiredData(){
        try{
            let user_id = await validateTheUser();
            if(user_id == null){
                console.log("User Id is null");
                res.status(401).json({message:"Invalid User"})
            }else{
                let accessToken = await comparePasswords(user_id);
                if(accessToken == null){
                    res.status(401).json({message:"Invaid Password"})
                }else{
                    let userRoles = await getUserRoles(user_id);
                    let screensForRoles = await getScreensForRoles(userRoles);
                    console.log("Screens for  roles" ,screensForRoles);
                    res.status(200).json({accessToken:accessToken,roles:userRoles,screens:screensForRoles})        
                }
            }
        }catch(err){
            res.status(401).json({message:"Invaid User / Password"})
        }

//         console.log("Screens required are ",screensForRoles);
//        if(accessToken != null){
//            console.log("Validation successful");
//            res.status(200).json({accessToken:accessToken,roles:userRoles})        
//        }else{
//            console.log("Validation failure");
//            res.status(401).json({message:"Password Validation Failed"});
//        } 
        
    }
    
}*/
/////17Apr2025/////
//new//
const msalConfig = {
  auth: {
    clientId: '7c3fa100-b06a-439e-9a8f-5286c727e91c',
    authority: 'https://login.microsoftonline.com/8f9372d6-92ff-4057-809f-2f0a599a2e21',
    clientSecret: 'XPo8Q~x~2Hw.ORjBubO2qH6l.8P6VS.7oEHu~b5d',
  },
};

const cca = new ConfidentialClientApplication(msalConfig);

const REDIRECT_URI = 'https://uat-explorer.adamma.in';
const SCOPES = ['Mail.Send', 'User.Read'];
const senderEmail = 'info@adamma.in';

exports.validate = async (req, res) => {
  try {
    const user = await User.findOne({ userId: req.body.userId });
    if (!user) return res.status(401).json({ message: 'Invalid User' });

    const userPassword = await UserPassword.findOne({ user: user._id });
    if (!userPassword) return res.status(401).json({ message: 'User password not found' });

    const isMatch = await comparePassword(userPassword, req.body.password);
    if (!isMatch) return res.status(401).json({ message: 'Invalid Password' });

    // Generate and store OTP
    const otp = generateOTP();
    await UserPassword.findOneAndUpdate({ user: user._id }, { otp });

    // Get access token via client credentials
    const accessToken = await getAccessTokenGraph();

    // Send OTP email via Microsoft Graph API
    await sendGraphEmail(req.body.userId, otp, accessToken);

    return res.status(200).json({ success: true });

  } catch (err) {
    console.error('Error in validate:', err.message);
    return res.status(500).json({ message: 'Something went wrong' });
  }
};

// --- Helpers ---

function comparePassword(userPassword, password) {
  return new Promise((resolve, reject) => {
    userPassword.comparePassword(password, (err, isMatch) => {
      if (err) return reject(err);
      resolve(isMatch);
    });
  });
}

function generateOTP() {
  return Math.floor(100000 + Math.random() * 900000);
}

/*async function getAccessTokenGraph() {
  const result = await cca.acquireTokenByClientCredential({
    scopes: ['https://graph.microsoft.com/.default'],
  });
  return result.accessToken;
}*/
async function getAccessTokenGraph() {
  try {
    const result = await cca.acquireTokenByClientCredential({
      scopes: ['https://graph.microsoft.com/.default'],
    });
    console.log("Graph token:", result.accessToken);
    return result.accessToken;
  } catch (error) {
    console.error("Error obtaining Graph access token:", error);
    throw error;
  }
}

async function getAccessTokenSharePoint() {
  try {
    const result = await cca.acquireTokenByClientCredential({
      scopes: ['https://xxx.sharepoint.com/.default'],
    });
    console.log("SharePoint token:", result.accessToken);
    return result.accessToken;
  } catch (error) {
    console.error("Error obtaining SharePoint access token:", error);
    throw error;
  }
}

//console.log("after result.accessToken",accessToken)

async function sendGraphEmail(toEmail, otp, accessToken) {
	console.log("after result.accessToken",accessToken, toEmail, otp)
  const emailContent = `
    Dear Explorer User,

    OTP to sign in to Explorer is ${otp}

    Need any help with the account?
    Write to info@adamma.in

    This is an autogenerated email, please do not respond.

    Thank you,
    Team Explorer
  `;

  const emailData = {
    message: {
      subject: 'OTP to sign in to Explorer',
      body: {
        contentType: 'Text',
        content: emailContent,
      },
      toRecipients: [{ emailAddress: { address: toEmail } }],
    },
    saveToSentItems: true,
  };
	 const senderEmail = 'info@adamma.in'; // Must have mailbox + permissions
	console.log(`log ${accessToken}`);
  const url = `https://graph.microsoft.com/v1.0/users/${senderEmail}/sendMail`;

  // Decode the access token for debugging
  console.log("Decoded access token:", JSON.parse(Buffer.from(accessToken.split('.')[1], 'base64').toString()));
	 // const url = 'https://graph.microsoft.com/v1.0/info@adamma.in/sendMail'; // Using /me/sendMail with delegated permissions

  try {
	   console.log(`log ${accessToken}`);
    const response = await axios.post(url, emailData, {
	    
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
    });
    console.log('Email sent successfully:', response.data);
  } catch (err) {
    console.error('Error in sending email:', err.response ? err.response.data : err.message);
    throw err;
  }

//}


  /*await axios.post('https://graph.microsoft.com/v1.0/users/' + senderEmail + '/sendMail', emailData, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
  });*/
}

/////////
/*exports.validate = (req,res)=>{
    let validateTheUser = function(){
        return new Promise(function(resolve,reject){
            User.findOne({userId:req.body.userId})
            .then(user=>{
                if(user != null){
                    resolve(user._id)
                }else{
                  reject(null);
                }
            })
            .catch(err=>{
                reject(null)
            })
        })
    }

    let comparePasswords = function(user_id){
        return new Promise(function(resolve,reject){
            UserPassword.findOne({user:user_id})
            .then(userPassword=>{
                if(userPassword){
                    userPassword.comparePassword(req.body.password,function(err,isMatch){
                        if(err){
                            reject(false);
                        }
                        if(isMatch){
//                            const accessToken = generateToken({user_id:user_id},"ACCESS");
                            resolve(true)
                        }else{
                            reject(false)
                        }
                    })
                }else{
                    reject(false)
                }
            })
            .catch(err=>{
                reject(false);
            })
        })

    }
    let getUserRoles = function(user_id){
        return new Promise(function(resolve,reject){
            UserRole
            .find({user:user_id})
            .then(data=>{
                let roles = new Array();
                data.forEach(item=>{
                    roles.push(item.role);
                })
                resolve(roles);
            })
            .catch(err=>{
                reject(null);
            })
        })
    }
    let getScreensForRoles = function(roles){
        return new Promise(function(resolve,reject){
            let roleObjectArray = new Array();
            roles.forEach(item=>{
                let roleObj = ({
                    role:item
                })
                roleObjectArray.push(roleObj);
            })
            ScreenAccess
            .find({$or:roleObjectArray})
            .populate({path:'screen'})
            .then(data=>{
                let screens = ''
                data.forEach(item=>{
                    let requiredScreen = ({
                        screen_id:item.screen._id,
                        name:item.screen.name,
                        code:item.screen.code
                    })
                    screens = screens + item.screen.code + ','
                })
                console.log("screens being sent back is ",screens);
                resolve(screens)
            })
            .catch(err=>{
                reject(null);
            })
        })
    }

const nodeMailer = require("nodemailer");
const { create } = require("simple-oauth2");
console.log("calling Oauth")
// OAuth2 Config
const oauthConfig = {
    client: {
        id: "7c3fa100-b06a-439e-9a8f-5286c727e91c",
        secret: "XPo8Q~x~2Hw.ORjBubO2qH6l.8P6VS.7oEHu~b5d"
    },
    auth: {
        tokenHost: "https://login.microsoftonline.com",
        tokenPath: "/8f9372d6-92ff-4057-809f-2f0a599a2e21/oauth2/v2.0/token"
    }
};
console.log("Sender ID")
// Your sender email
const senderEmail = "info@adamma.in";

async function validateAndSendTheRequiredData(req, res) {
    try {
        let user_id = await validateTheUser();
        if (!user_id) {
            console.log("User Id is null");
            return res.status(401).json({ message: "Invalid User" });
        }

        let success = await comparePasswords(user_id);
        console.log("Success is", success);

        if (!success) {
            return res.status(401).json({ success: success });
        }

        // Generate OTP
        const otp = Math.floor(100000 + Math.random() * 900000);

        await UserPassword.findOneAndUpdate({ user: user_id }, { otp: otp });

        // Create OAuth2 client
        const oauth2Client = create(oauthConfig);

        const tokenParams = {
            scope: "https://outlook.office365.com/.default"
        };

        const token = await oauth2Client.clientCredentials.getToken(tokenParams);
        const accessToken = token.token.access_token;
        console.log("Token") 
        // Nodemailer setup
        const transporter = nodeMailer.createTransport({
            host: "smtp.office365.com",
            port: 587,
            secure: false,
            auth: {
                type: "OAuth2",
                user: senderEmail,
                accessToken: accessToken
            }
        });

        const mailOptions = {
            from: senderEmail,
            to: req.body.userId, // Or hardcode if testing
            subject: "OTP to sign in to Explorer",
            text: `Dear Explorer User,\n\nOTP to sign in to Explorer is ${otp}\n\nNeed any help with the account?\nWrite to info@adamma.in\n\nThis is an autogenerated email, please do not respond.\n\nThank you,\nTeam Explorer`
        };

        transporter.sendMail(mailOptions, function (error, info) {
            if (error) {
                console.log("Email error: ", error);
                return res.status(500).json({ message: error.message || "Error sending OTP" });
            } else {
                console.log("Email sent: ", info.messageId);
                return res.status(200).json({ success: true });
            }
        });

    } catch (err) {
        console.error("Caught error: ", err);
        return res.status(401).json({ message: "Invalid User / Password" });
    }
}*/
/////17Apr2025/////



    
/**validateAndSendTheRequiredData();
    async function validateAndSendTheRequiredData(){
        try{
            let user_id = await validateTheUser();
            if(user_id == null){
                console.log("User Id is null");
                res.status(401).json({message:"Invalid User"})
            }else{
                let success = await comparePasswords(user_id);
                console.log("Success is ",success)
                if(success != true){
                    res.status(401).json({sucess:sucess})
                }else{
//                    let userRoles = await getUserRoles(user_id);
//                    let screensForRoles = await getScreensForRoles(userRoles);
//                    console.log("Screens for  roles" ,screensForRoles);
                    var val = Math.floor(100000 + Math.random() * 900000);
                    UserPassword
                    .findOneAndUpdate({user:user_id},{otp:val})
                    .then(data=>{
                           let transporter = nodeMailer.createTransport({
                               host:"smtp.office365.com",
                               port:587,
                               secure:false,
                               auth:{
                                     user:"info@adamma.in",
                                     pass:"Adamma@123"
                               }
                          })
                          let mailOptions = {
                              from:"info@adamma.in",
                              to:req.body.userId,
//                            to:"manjunath.srikantiah@utkrusht.com",
                              subject:"OTP to sigin to Explorer",
                              text: "Dear Explorer User,\n\nOTP to sigin to Explorer is " + val + "\n\n" + "Need any help with the account?" + "Write to info@adamma.in\n\n" + "This is autogenerated email, please do not respond.\n\n" + "Thank you,\n" + "Team Explorer"
            }
                             transporter.sendMail(mailOptions,function(error,info){
                                  if(error){
                                    console.log(error);
                                    res.status(500).json({message:error.message || "Some error occured while generating otp"})
                                  }else{
                                     res.status(200).json({success:success});
                                  }
                             })

                    })

//                  console.log("Otp generated is ",val)
//                    res.status(200).json({success:success})
                }
            }
        }catch(err){
            res.status(401).json({message:"Invaid User / Password"})
        }**/

/*         console.log("Screens required are ",screensForRoles);
        if(accessToken != null){
            console.log("Validation successful");
            res.status(200).json({accessToken:accessToken,roles:userRoles})
        }else{
            console.log("Validation failure");
            res.status(401).json({message:"Password Validation Failed"});
        } */

   /* }*/

//}
					  


exports.validateForChangePassword=(req,res)=>{
    console.log(req.user.user_id);
    User
    .findOne({_id:req.user.user_id})
    .then(data=>{
        UserPassword
        .findOne({user:req.user.user_id})
        .then(userPassword=>{
            if(userPassword){
                userPassword.comparePassword(req.body.password,function(err,isMatch){
                    if(err){
                        res.json({message:false});
                    }
                    if(isMatch){
                        res.json({message:true})
                    }
                }
                )
            }else{
                res.json({message:false})
            }                    
        })
        .catch(err=>{
            res.json({message:false})
        })        
    })    
    .catch(err=>{
        res.json({message:false})
    })
}
exports.createForChangePassword = (req,res)=>{
    UserPassword.deleteOne({user:req.user.user_id})
    .then(userPassword=>{
        savePassword();
    })
    function savePassword(){
        const userPassword = new UserPassword({
            user:req.user.user_id,
            password:req.body.password
        })
        userPassword.save(userPassword)
        .then(data=>{
            res.status(200).json({message:"Password generated successfully"});
        })
        .catch(err=>{
            res.status(500).json({message:err.message || "Some error occured while saving user password"})
        })        
    }

}
//code 13 Jan 2023
exports.validatePasswordForMobileApp = (req,res)=>{

  let validateTheUser = function(){
        return new Promise(function(resolve,reject){
            User.findOne({userId:req.body.userId})
            .then(user=>{
                if(user != null){
                    resolve(user._id)
                }else{
                  reject(null);
                }
            })
            .catch(err=>{
                console.log("Error finding the user")
                reject(null)
            })
        })
    }
    let comparePasswords = function(user_id){
        return new Promise(function(resolve,reject){
            UserPassword.findOne({user:user_id})
            .then(userPassword=>{
                if(userPassword){
                    userPassword.comparePassword(req.body.password,function(err,isMatch){
                        if(err){
                            resolve(null);
                        }
                        if(isMatch){
                            const accessToken = generateToken({user_id:user_id},"ACCESS");
                            resolve(accessToken)
                        }else{
                            resolve(null)
                        }
                    })
                }else{
                    resolve(null)
                }
            })
            .catch(err=>{
                resolve(null);
            })
        })

    }
    validateAndSendAccessToken()
    async function validateAndSendAccessToken (){
       let userId = await validateTheUser()
       if(userId != null){
           let accessToken = await comparePasswords(userId)
           if(accessToken != null){
              res.json({
                 accessToken :accessToken
              })
           }else{
               res.status(401).json({
                       message:"Password does not match"
               })
           }
       }else{
           res.status(401).json({
               message:"User Not Found"
           })
       }

    }



}


/// 6-May-2025 Forgot Password Email
async function sendForgotPasswordEmail(toEmail, password, accessToken) {
	console.log("after result.accessToken",accessToken, toEmail, password)
  const emailContent = `
    Dear Explorer User,

    New Password Generated to sign in to Explorer is ${password}

    Need any help with the account?
    Write to info@adamma.in

    This is an autogenerated email, please do not respond.

    Thank you,
    Team Explorer
  `;

  const emailData = {
    message: {
      subject: 'New Password Generated to sign in to Explorer',
      body: {
        contentType: 'Text',
        content: emailContent,
      },
      toRecipients: [{ emailAddress: { address: toEmail } }],
    },
    saveToSentItems: true,
  };
	 const senderEmail = 'info@adamma.in'; // Must have mailbox + permissions
	// console.log(`log ${accessToken}`);
  const url = `https://graph.microsoft.com/v1.0/users/${senderEmail}/sendMail`;
  try {
	   //console.log(`log ${accessToken}`);
    const response = await axios.post(url, emailData, {
	    
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
    });
    console.log('Email sent successfully:', response.data);
  } catch (err) {
    console.error('Error in sending email:', err.response ? err.response.data : err.message);
    throw err;
  }

}



///////Forget Password
exports.forgotPassword = async (req, res) => {
    console.log("sdscdsdcwesdcw",req.body.userId);
    const userId = req.body.userId;

    try {
        // Check if the user exists
        const userData = await User.findOne({ userId: userId });
        console.log("email id is:", userData);
        if (!userData) {
            return res.status(404).json({ message: "User ID does not exist" });
        }

        // Delete the existing password for the particular user
        await UserPassword.deleteOne({ user: userData._id });

        const bytes = crypto.randomBytes(8);
        const password = bytes.slice(0, 4).toString('hex');

        const userPassword = new UserPassword({
            user: userData._id,
            password: password,
            lastUpdated: new Date(),
        });
        await userPassword.save();
	console.log("passswwoord",password)

        /*const subject = `New Password Generated - ${userData.name}`;
        const html = `
            <p>Hi ${userData.name} ,</p>
            <p><br></p>
            <p>Your Password has been  changed successfully , and a new  default password has been generated for you.</p>
            <p>Please make sure to change your password after you log in.</p>
            <p>You can log in with the following credentials:</p>
            <p><br></p>
            <p>Username: ${userData.userId}</p>
            <p>Password: ${password}</p>
            <p><br></p>
            <p>Thank you,</p>
            <p>Team IT | Adamma.</p>
        `;
        sendMail(userData.userId, subject, html);
	*/

         const accessToken = await getAccessTokenGraph();
        await sendForgotPasswordEmail(req.body.userId, password, accessToken);

        return res.status(200).json({ message: "Password generated and mail sent successfully!" });

    } catch (err) {
        console.log(err);
        return res.status(500).json({ message: "Could not generate password: " + err.message });
    }
}
